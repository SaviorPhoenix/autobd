package index

import (
	"bufio"
	"crypto/sha512"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"time"

	"github.com/tywkeene/autobd/options"
	"github.com/tywkeene/autobd/utils"
)

//Index is the structure generated by the GenerateIndex() and GetIndex() maps
type Index struct {
	//Name is the filename of the file or directory indexed
	Name string `json:"name"`
	//Checksum is the checksum of the file, empty if filetype is a directory
	//Empty if directory
	Checksum string `json:"checksum,omitempty"`
	//Size is the size of the file in bytes
	Size int64 `json:"size"`
	//Modtime is the timestamp of the last modification of the file
	ModTime time.Time `json:"lastModified"`
	//Mode is a representation of the UNIX permissions of this file
	Mode os.FileMode `json:"fileMode"`
	//IsDir is this file a regular file or a directory
	IsDir bool `json:"isDir"`
	//Files is the files contained in the directory referenced by this structure
	//Empty if file
	Files map[string]*Index `json:"files,omitempty"`
}

//GetChecksum returns the SHA512 hash of the file at 'path'.
func GetChecksum(path string) string {
	defer utils.TimeTrack(time.Now(), "index/GetChecksum()")
	file, err := os.Open(path)
	if utils.HandleError(err, utils.ErrorActionErr) == true {
		return ""
	}
	defer file.Close()

	hash := sha512.New()
	buf := bufio.NewReader(file)

	_, err = buf.WriteTo(hash)
	if utils.HandleError(err, utils.ErrorActionErr) == true {
		return ""
	}

	sum := hex.EncodeToString(hash.Sum(nil))
	return sum
}

func NewIndex(name string, size int64, modtime time.Time, mode os.FileMode, isDir bool) *Index {
	var checksum string
	if isDir == false {
		checksum = GetChecksum(name)
	} else {
		checksum = ""
	}
	return &Index{name, checksum, size, modtime, mode, isDir, nil}
}

//GenerateIndex Recursively genearates an index for dirPath, and returns a map of
//the directory tree, indexed by filepath
func GenerateIndex(dirPath string) (map[string]*Index, error) {
	defer utils.TimeTrack(time.Now(), "index/GenerateIndex()")
	list, err := ioutil.ReadDir(dirPath)
	if err != nil {
		return nil, err
	}
	index := make(map[string]*Index)
	for _, child := range list {
		if child.Name() == options.Config.NodeListFile {
			continue
		}
		childPath := path.Join(dirPath, child.Name())
		index[childPath] = NewIndex(childPath, child.Size(), child.ModTime(), child.Mode(), child.IsDir())
		if child.IsDir() == true {
			childContent, err := GenerateIndex(childPath)
			if err != nil {
				return nil, err
			}
			index[childPath].Files = childContent
		}
	}
	return index, nil
}

func ValidateDirectory(dirPath string) (string, error) {
	dirStat, err := os.Lstat(dirPath)
	if err != nil {
		return "", err
	}
	if dirStat.IsDir() == false {
		return "", fmt.Errorf("Not a directory")
	}
	if dirPath == "/" || dirPath == "../" ||
		dirPath == ".." || dirPath == "." {
		dirPath = "./"
	}
	return dirPath, nil
}

//GetIndex validates dirPath, and calls GenerateIndex on it
func GetIndex(dirPath string) (map[string]*Index, error) {
	defer utils.TimeTrack(time.Now(), "index/GetIndex()")
	validPath, err := ValidateDirectory(dirPath)
	if err != nil {
		return nil, err
	}
	return GenerateIndex(validPath)
}
